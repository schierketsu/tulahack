{
  "version": 3,
  "sources": ["../../@yandex/ymaps3-clusterer/dist/esm/YMapClusterer/constants.js", "../../@yandex/ymaps3-clusterer/dist/esm/YMapClusterer/helpers/throttle.js", "../../@yandex/ymaps3-clusterer/dist/esm/YMapClusterer/react/YMapClusterer.js", "../../@yandex/ymaps3-clusterer/dist/esm/YMapClusterer/vue/YMapClusterer.js", "../../@yandex/ymaps3-clusterer/dist/esm/YMapClusterer/YMapClusterer.js", "../../@yandex/ymaps3-clusterer/dist/esm/YMapClusterer/helpers/utils.js", "../../@yandex/ymaps3-clusterer/dist/esm/YMapClusterer/methods/clusterByGrid.js"],
  "sourcesContent": ["export const THROTTLE_DEFAULT_TIMEOUT_MS = 200;\n", "/**\n * Throttles a function and delays its execution, so it's only called at most\n * once within a given time period.\n *\n * @param {Function} fn The function to throttle.\n * @param {number} wait The amount of time that must pass before the function can be called again.\n * @return {Function} The throttled function.\n */\nexport const throttle = (fn, wait) => {\n    let inThrottle;\n    let lastFn;\n    let lastTime;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return function () {\n        const context = this;\n        const args = arguments;\n        if (!inThrottle) {\n            fn.apply(context, args);\n            lastTime = Date.now();\n            inThrottle = true;\n        }\n        else {\n            clearTimeout(lastFn);\n            lastFn = setTimeout(() => {\n                if (Date.now() - lastTime >= wait) {\n                    fn.apply(context, args);\n                    lastTime = Date.now();\n                }\n            }, Math.max(wait - (Date.now() - lastTime), 0));\n        }\n    };\n};\n", "export const YMapClustererReactifyOverride = (YMapClustererI, { reactify, React }) => {\n    const YMapClustererReactified = reactify.entity(YMapClustererI);\n    const YMapClusterer = React.forwardRef((props, ref) => {\n        const [clusters, setClusters] = React.useState([]);\n        const onRender = React.useCallback((clusters) => {\n            const reactClusters = {};\n            clusters.forEach(({ lnglat, features, clusterId }) => {\n                reactClusters[clusterId] = (React.createElement(React.Fragment, { key: clusterId }, features.length === 1\n                    ? props.marker(features[0])\n                    : props.cluster(lnglat, features)));\n            });\n            setClusters(Object.values(reactClusters));\n            return false;\n        }, [props]);\n        return (React.createElement(React.Fragment, null,\n            React.createElement(YMapClustererReactified, { ...props, ref: ref, onRender: onRender }),\n            clusters));\n    });\n    return YMapClusterer;\n};\n", "import { THROTTLE_DEFAULT_TIMEOUT_MS } from '../constants';\nexport const YMapClustererVuefyOptions = {\n    props: {\n        method: { type: Object, required: true },\n        features: { type: Array, required: true },\n        marker: Function,\n        cluster: Function,\n        tickTimeout: { type: Number, default: THROTTLE_DEFAULT_TIMEOUT_MS },\n        onRender: Function,\n        maxZoom: { type: Number }\n    }\n};\nexport const YMapClustererVuefyOverride = (YMapClustererI, props, { vuefy, Vue }) => {\n    const YMapClustererV = vuefy.entity(YMapClustererI, props);\n    const YMapCollectionV = vuefy.entity(ymaps3.YMapCollection);\n    return Vue.defineComponent({\n        name: 'YMapClustererContainer',\n        props,\n        slots: Object,\n        setup(props, { slots }) {\n            const clustersVNode = Vue.ref(null);\n            const onRender = (clusters) => {\n                const vueClusters = {};\n                clusters.forEach(({ lnglat, features, clusterId }) => {\n                    var _a, _b;\n                    vueClusters[clusterId] = Vue.h(Vue.Fragment, { key: clusterId }, features.length === 1\n                        ? (_a = slots.marker) === null || _a === void 0 ? void 0 : _a.call(slots, { feature: features[0] })\n                        : (_b = slots.cluster) === null || _b === void 0 ? void 0 : _b.call(slots, { coordinates: lnglat, features }));\n                });\n                clustersVNode.value = Object.values(vueClusters);\n                return false;\n            };\n            return () => [\n                Vue.h(YMapClustererV, { ...props, onRender }),\n                Vue.h(YMapCollectionV, () => clustersVNode.value)\n            ];\n        }\n    });\n};\n", "var _a, _b, _c;\nimport { THROTTLE_DEFAULT_TIMEOUT_MS } from './constants';\nimport { throttle } from './helpers/throttle';\nimport { YMapClustererReactifyOverride } from './react/YMapClusterer';\nimport { YMapClustererVuefyOverride, YMapClustererVuefyOptions } from './vue/YMapClusterer';\nconst defaultProps = Object.freeze({\n    tickTimeout: THROTTLE_DEFAULT_TIMEOUT_MS\n});\n/**\n * Display clustered features on a map.\n *\n * @example\n * ```javascript\n * const clusterer = new YMapClusterer({\n *      method: clusterByGrid({gridSize: 64}),\n *      features: POINTS,\n *      marker: (feature) => new YMapMarker({\n *          coordinates: feature.geometry.coordinates,\n *          source: 'my-source'\n *      }\n *      cluster: (coordinates, cluster) => new YMapMarker({\n *          coordinates,\n *          source: 'my-source'\n *      }\n * });\n *\n * map.addChild(new YMapDefaultSchemeLayer())\n *      .addChild(new YMapFeatureDataSource({id: 'my-source'}))\n *      .addChild(new YMapLayer({source: 'my-source', type: 'markers'}))\n *      .addChild(clusterer);\n * ```\n */\nclass YMapClusterer extends ymaps3.YMapComplexEntity {\n    constructor(props) {\n        super(props);\n        /** All created entities with cluster id*/\n        this._entitiesCache = {};\n        /** Viewport entities with cluster id */\n        this._visibleEntities = {};\n        this._render = this._render.bind(this);\n    }\n    /**\n     * Compare feature coordinates with bounds.\n     * Visible in x2 bounds.\n     *\n     * @param feature\n     * @param bounds\n     * @param projection\n     * @returns either feature belongs to viewport or not\n     */\n    _isVisible(feature, bounds, projection) {\n        const { x, y } = projection.toWorldCoordinates(feature.geometry.coordinates);\n        const { x: x1, y: y1 } = projection.toWorldCoordinates(bounds[0]);\n        const { x: x2, y: y2 } = projection.toWorldCoordinates(bounds[1]);\n        const boundsWidth = x2 - x1;\n        const boundsHeight = y1 - y2;\n        return (x1 - boundsWidth / 2 <= x &&\n            x2 + boundsWidth / 2 >= x &&\n            y1 + boundsHeight / 2 >= y &&\n            y2 - boundsHeight / 2 <= y);\n    }\n    /**\n     * Get entity from store or create it\n     *\n     * @param feature\n     * @param entityId\n     * @param length count of entities in the cluster\n     * @returns ready to add to map entity\n     */\n    _getEntity({ lnglat, features, clusterId: entityId }) {\n        let entity = this._entitiesCache[entityId];\n        if (!entity) {\n            if (features.length === 1) {\n                entity = this._props.marker(features[0]);\n            }\n            else {\n                entity = this._props.cluster(lnglat, features);\n            }\n            this._entitiesCache[entityId] = entity;\n        }\n        return entity;\n    }\n    /**\n     * Generate map of new entities based on returned from method objects\n     *\n     * @param nextViewportObjects clustered objects\n     * @returns map of entities for new render\n     */\n    _getVisibleEntities(nextViewportObjects) {\n        const nextVisibleEntities = {};\n        nextViewportObjects.forEach((object) => {\n            const entity = this._getEntity(object);\n            nextVisibleEntities[object.clusterId] = entity;\n        });\n        return nextVisibleEntities;\n    }\n    /**\n     * Removes unnecessary entities and adds new to the map\n     *\n     * @param nextVisibleEntities new entities for matching with existing entities\n     */\n    _syncVisibleEntities(nextVisibleEntities) {\n        for (const entityId in this._visibleEntities) {\n            if (!nextVisibleEntities[entityId]) {\n                this._container.removeChild(this._visibleEntities[entityId]);\n            }\n        }\n        for (const entityId in nextVisibleEntities) {\n            if (!this._visibleEntities[entityId]) {\n                this._container.addChild(nextVisibleEntities[entityId]);\n            }\n        }\n    }\n    _render({ mapInAction } = {}) {\n        const map = this.root;\n        if (!map || mapInAction)\n            return;\n        const visibleFeatures = this._props.features.filter((feature) => this._isVisible(feature, map.bounds, map.projection));\n        let nextViewportObjects;\n        if (this._props.maxZoom && map.zoom > this._props.maxZoom) {\n            nextViewportObjects = visibleFeatures.map((feature) => ({\n                world: map.projection.toWorldCoordinates(feature.geometry.coordinates),\n                lnglat: feature.geometry.coordinates,\n                clusterId: feature.id,\n                features: [feature]\n            }));\n        }\n        else {\n            nextViewportObjects = this._props.method.render({\n                map,\n                features: visibleFeatures\n            });\n        }\n        if (this._props.onRender && this._props.onRender(nextViewportObjects) === false) {\n            return;\n        }\n        const nextVisibleEntities = this._getVisibleEntities(nextViewportObjects);\n        this._syncVisibleEntities(nextVisibleEntities);\n        this._visibleEntities = nextVisibleEntities;\n    }\n    _onAttach() {\n        this._entitiesCache = {};\n        this._visibleEntities = {};\n        this._container = new ymaps3.YMapCollection({});\n        this.addChild(this._container);\n        const onUpdateRender = this._props.tickTimeout ? throttle(this._render, this._props.tickTimeout) : this._render;\n        this._mapListener = new ymaps3.YMapListener({ onUpdate: onUpdateRender, onResize: onUpdateRender });\n        this.addChild(this._mapListener);\n        this._render();\n    }\n    _onDetach() {\n        this.removeChild(this._container);\n        this.removeChild(this._mapListener);\n        this._entitiesCache = {};\n        this._visibleEntities = {};\n    }\n    _onUpdate() {\n        this._render();\n    }\n}\n_a = ymaps3.overrideKeyReactify, _b = ymaps3.overrideKeyVuefy, _c = ymaps3.optionsKeyVuefy;\nYMapClusterer.__implName = 'YMapClusterer';\nYMapClusterer.defaultProps = defaultProps;\n/** @internal */\nYMapClusterer[_a] = YMapClustererReactifyOverride;\nYMapClusterer[_b] = YMapClustererVuefyOverride;\nYMapClusterer[_c] = YMapClustererVuefyOptions;\nexport { YMapClusterer };\n", "// World at 0 zoom is always 256x256 pixels.\nconst worldPixelSize = 256;\n/**\n * Divides a vector by another one component wise and stores the result into a\n * third one.\n *\n * @param a The dividend vector.\n * @param b The divisor vector.\n * @param dst The vector the result will be stored to.\n * @returns `dst`.\n */\nfunction divv(a, b, dst = { x: 0, y: 0 }) {\n    dst.x = a.x / b.x;\n    dst.y = a.y / b.y;\n    return dst;\n}\n/**\n * Divides a vector by a scalar and stores the result into a third vector.\n *\n * @param v The dividend vector.\n * @param n The scalar.\n * @param dst The vector the result will be stored to.\n * @returns `dst`.\n */\nexport function divn(v, n, dst = { x: 0, y: 0 }) {\n    dst.x = v.x / n;\n    dst.y = v.y / n;\n    return dst;\n}\nexport function convertPixelSizeToWorldSize(pixel, zoom, dst) {\n    const scale = (2 ** zoom / 2) * worldPixelSize;\n    return divv(pixel, { x: scale, y: -scale }, dst);\n}\n", "import { convertPixelSizeToWorldSize, divn } from \"../helpers/utils\";\nclass ClusterByGridMethod {\n    constructor(gridSize) {\n        this._nextFeatureIndex = 0;\n        this._featureIdCharCache = {};\n        this._gridSize = gridSize;\n    }\n    _getClusterSizeWorld(targetZoom) {\n        return convertPixelSizeToWorldSize({ x: this._gridSize, y: 0 }, targetZoom).x;\n    }\n    _computeVisibleClusters(size, targetZoom, center) {\n        const halfViewportSize = divn(convertPixelSizeToWorldSize(size, targetZoom), 2);\n        const top = center.y + halfViewportSize.y;\n        const bottom = center.y - halfViewportSize.y;\n        const left = center.x - halfViewportSize.x;\n        const right = center.x + halfViewportSize.x;\n        const clusterSize = this._getClusterSizeWorld(targetZoom);\n        const minBucketX = Math.floor(left / clusterSize);\n        const maxBucketX = Math.ceil(right / clusterSize);\n        const minBucketY = Math.floor(top / clusterSize);\n        const maxBucketY = Math.ceil(bottom / clusterSize);\n        const result = new Map();\n        for (let x = minBucketX; x <= maxBucketX; x++) {\n            for (let y = minBucketY; y <= maxBucketY; y++) {\n                result.set(`${x}-${y}`, true);\n            }\n        }\n        return result;\n    }\n    _clusterize(map, features, targetZoom) {\n        const clusters = new Map();\n        const clusterSize = this._getClusterSizeWorld(targetZoom);\n        for (const feature of features) {\n            const object = {\n                world: map.projection.toWorldCoordinates(feature.geometry.coordinates),\n                lnglat: feature.geometry.coordinates,\n                clusterId: '',\n                features: [feature]\n            };\n            const clusterX = Math.floor(object.world.x / clusterSize);\n            const clusterY = Math.floor(object.world.y / clusterSize);\n            const id = `${clusterX}-${clusterY}`;\n            let cluster = clusters.get(id);\n            if (!cluster) {\n                cluster = { sumX: 0, sumY: 0, objects: [], features: [] };\n                clusters.set(id, cluster);\n            }\n            cluster.sumX += object.world.x;\n            cluster.sumY += object.world.y;\n            cluster.objects.push(object);\n            cluster.features.push(object.features[0]);\n        }\n        return clusters;\n    }\n    _generateClusterId(features) {\n        const result = ['cluster-'];\n        features.forEach(({ id }) => {\n            if (!this._featureIdCharCache[id]) {\n                this._featureIdCharCache[id] = String.fromCharCode(this._nextFeatureIndex);\n                this._nextFeatureIndex += 1;\n            }\n            result.push(this._featureIdCharCache[id]);\n        });\n        return result.join('');\n    }\n    render({ map, features }) {\n        const targetZoom = Math.round(map.zoom);\n        const visibleClusters = this._computeVisibleClusters(map.size, targetZoom, map.projection.toWorldCoordinates(map.center));\n        const currentCollection = this._clusterize(map, features, targetZoom);\n        const nextViewportObjects = [];\n        for (const [clusterId, cluster] of currentCollection.entries()) {\n            if (!visibleClusters.get(clusterId))\n                continue;\n            const length = cluster.objects.length;\n            if (length === 1) {\n                nextViewportObjects.push({\n                    ...cluster.objects[0],\n                    clusterId: cluster.features[0].id\n                });\n            }\n            else {\n                const world = { x: cluster.sumX / length, y: cluster.sumY / length };\n                nextViewportObjects.push({\n                    world,\n                    lnglat: map.projection.fromWorldCoordinates(world),\n                    clusterId: this._generateClusterId(cluster.features),\n                    features: cluster.features\n                });\n            }\n        }\n        return nextViewportObjects;\n    }\n}\nexport function clusterByGrid({ gridSize }) {\n    return new ClusterByGridMethod(gridSize);\n}\n"],
  "mappings": "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",
  "names": ["YMapClusterer", "clusters", "props", "_a", "_b"]
}
