{
  "version": 3,
  "sources": ["../../@yandex/ymaps3-clusterer/dist/esm/YMapClusterer/constants.js", "../../@yandex/ymaps3-clusterer/dist/esm/YMapClusterer/helpers/throttle.js", "../../@yandex/ymaps3-clusterer/dist/esm/YMapClusterer/react/YMapClusterer.js", "../../@yandex/ymaps3-clusterer/dist/esm/YMapClusterer/vue/YMapClusterer.js", "../../@yandex/ymaps3-clusterer/dist/esm/YMapClusterer/YMapClusterer.js", "../../@yandex/ymaps3-clusterer/dist/esm/YMapClusterer/helpers/utils.js", "../../@yandex/ymaps3-clusterer/dist/esm/YMapClusterer/methods/clusterByGrid.js"],
  "sourcesContent": ["export const THROTTLE_DEFAULT_TIMEOUT_MS = 200;\r\n", "/**\r\n * Throttles a function and delays its execution, so it's only called at most\r\n * once within a given time period.\r\n *\r\n * @param {Function} fn The function to throttle.\r\n * @param {number} wait The amount of time that must pass before the function can be called again.\r\n * @return {Function} The throttled function.\r\n */\r\nexport const throttle = (fn, wait) => {\r\n    let inThrottle;\r\n    let lastFn;\r\n    let lastTime;\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    return function () {\r\n        const context = this;\r\n        const args = arguments;\r\n        if (!inThrottle) {\r\n            fn.apply(context, args);\r\n            lastTime = Date.now();\r\n            inThrottle = true;\r\n        }\r\n        else {\r\n            clearTimeout(lastFn);\r\n            lastFn = setTimeout(() => {\r\n                if (Date.now() - lastTime >= wait) {\r\n                    fn.apply(context, args);\r\n                    lastTime = Date.now();\r\n                }\r\n            }, Math.max(wait - (Date.now() - lastTime), 0));\r\n        }\r\n    };\r\n};\r\n", "export const YMapClustererReactifyOverride = (YMapClustererI, { reactify, React }) => {\r\n    const YMapClustererReactified = reactify.entity(YMapClustererI);\r\n    const YMapClusterer = React.forwardRef((props, ref) => {\r\n        const [clusters, setClusters] = React.useState([]);\r\n        const onRender = React.useCallback((clusters) => {\r\n            const reactClusters = {};\r\n            clusters.forEach(({ lnglat, features, clusterId }) => {\r\n                reactClusters[clusterId] = (React.createElement(React.Fragment, { key: clusterId }, features.length === 1\r\n                    ? props.marker(features[0])\r\n                    : props.cluster(lnglat, features)));\r\n            });\r\n            setClusters(Object.values(reactClusters));\r\n            return false;\r\n        }, [props]);\r\n        return (React.createElement(React.Fragment, null,\r\n            React.createElement(YMapClustererReactified, { ...props, ref: ref, onRender: onRender }),\r\n            clusters));\r\n    });\r\n    return YMapClusterer;\r\n};\r\n", "import { THROTTLE_DEFAULT_TIMEOUT_MS } from '../constants';\r\nexport const YMapClustererVuefyOptions = {\r\n    props: {\r\n        method: { type: Object, required: true },\r\n        features: { type: Array, required: true },\r\n        marker: Function,\r\n        cluster: Function,\r\n        tickTimeout: { type: Number, default: THROTTLE_DEFAULT_TIMEOUT_MS },\r\n        onRender: Function,\r\n        maxZoom: { type: Number }\r\n    }\r\n};\r\nexport const YMapClustererVuefyOverride = (YMapClustererI, props, { vuefy, Vue }) => {\r\n    const YMapClustererV = vuefy.entity(YMapClustererI, props);\r\n    const YMapCollectionV = vuefy.entity(ymaps3.YMapCollection);\r\n    return Vue.defineComponent({\r\n        name: 'YMapClustererContainer',\r\n        props,\r\n        slots: Object,\r\n        setup(props, { slots }) {\r\n            const clustersVNode = Vue.ref(null);\r\n            const onRender = (clusters) => {\r\n                const vueClusters = {};\r\n                clusters.forEach(({ lnglat, features, clusterId }) => {\r\n                    var _a, _b;\r\n                    vueClusters[clusterId] = Vue.h(Vue.Fragment, { key: clusterId }, features.length === 1\r\n                        ? (_a = slots.marker) === null || _a === void 0 ? void 0 : _a.call(slots, { feature: features[0] })\r\n                        : (_b = slots.cluster) === null || _b === void 0 ? void 0 : _b.call(slots, { coordinates: lnglat, features }));\r\n                });\r\n                clustersVNode.value = Object.values(vueClusters);\r\n                return false;\r\n            };\r\n            return () => [\r\n                Vue.h(YMapClustererV, { ...props, onRender }),\r\n                Vue.h(YMapCollectionV, () => clustersVNode.value)\r\n            ];\r\n        }\r\n    });\r\n};\r\n", "var _a, _b, _c;\r\nimport { THROTTLE_DEFAULT_TIMEOUT_MS } from './constants';\r\nimport { throttle } from './helpers/throttle';\r\nimport { YMapClustererReactifyOverride } from './react/YMapClusterer';\r\nimport { YMapClustererVuefyOverride, YMapClustererVuefyOptions } from './vue/YMapClusterer';\r\nconst defaultProps = Object.freeze({\r\n    tickTimeout: THROTTLE_DEFAULT_TIMEOUT_MS\r\n});\r\n/**\r\n * Display clustered features on a map.\r\n *\r\n * @example\r\n * ```javascript\r\n * const clusterer = new YMapClusterer({\r\n *      method: clusterByGrid({gridSize: 64}),\r\n *      features: POINTS,\r\n *      marker: (feature) => new YMapMarker({\r\n *          coordinates: feature.geometry.coordinates,\r\n *          source: 'my-source'\r\n *      }\r\n *      cluster: (coordinates, cluster) => new YMapMarker({\r\n *          coordinates,\r\n *          source: 'my-source'\r\n *      }\r\n * });\r\n *\r\n * map.addChild(new YMapDefaultSchemeLayer())\r\n *      .addChild(new YMapFeatureDataSource({id: 'my-source'}))\r\n *      .addChild(new YMapLayer({source: 'my-source', type: 'markers'}))\r\n *      .addChild(clusterer);\r\n * ```\r\n */\r\nclass YMapClusterer extends ymaps3.YMapComplexEntity {\r\n    constructor(props) {\r\n        super(props);\r\n        /** All created entities with cluster id*/\r\n        this._entitiesCache = {};\r\n        /** Viewport entities with cluster id */\r\n        this._visibleEntities = {};\r\n        this._render = this._render.bind(this);\r\n    }\r\n    /**\r\n     * Compare feature coordinates with bounds.\r\n     * Visible in x2 bounds.\r\n     *\r\n     * @param feature\r\n     * @param bounds\r\n     * @param projection\r\n     * @returns either feature belongs to viewport or not\r\n     */\r\n    _isVisible(feature, bounds, projection) {\r\n        const { x, y } = projection.toWorldCoordinates(feature.geometry.coordinates);\r\n        const { x: x1, y: y1 } = projection.toWorldCoordinates(bounds[0]);\r\n        const { x: x2, y: y2 } = projection.toWorldCoordinates(bounds[1]);\r\n        const boundsWidth = x2 - x1;\r\n        const boundsHeight = y1 - y2;\r\n        return (x1 - boundsWidth / 2 <= x &&\r\n            x2 + boundsWidth / 2 >= x &&\r\n            y1 + boundsHeight / 2 >= y &&\r\n            y2 - boundsHeight / 2 <= y);\r\n    }\r\n    /**\r\n     * Get entity from store or create it\r\n     *\r\n     * @param feature\r\n     * @param entityId\r\n     * @param length count of entities in the cluster\r\n     * @returns ready to add to map entity\r\n     */\r\n    _getEntity({ lnglat, features, clusterId: entityId }) {\r\n        let entity = this._entitiesCache[entityId];\r\n        if (!entity) {\r\n            if (features.length === 1) {\r\n                entity = this._props.marker(features[0]);\r\n            }\r\n            else {\r\n                entity = this._props.cluster(lnglat, features);\r\n            }\r\n            this._entitiesCache[entityId] = entity;\r\n        }\r\n        return entity;\r\n    }\r\n    /**\r\n     * Generate map of new entities based on returned from method objects\r\n     *\r\n     * @param nextViewportObjects clustered objects\r\n     * @returns map of entities for new render\r\n     */\r\n    _getVisibleEntities(nextViewportObjects) {\r\n        const nextVisibleEntities = {};\r\n        nextViewportObjects.forEach((object) => {\r\n            const entity = this._getEntity(object);\r\n            nextVisibleEntities[object.clusterId] = entity;\r\n        });\r\n        return nextVisibleEntities;\r\n    }\r\n    /**\r\n     * Removes unnecessary entities and adds new to the map\r\n     *\r\n     * @param nextVisibleEntities new entities for matching with existing entities\r\n     */\r\n    _syncVisibleEntities(nextVisibleEntities) {\r\n        for (const entityId in this._visibleEntities) {\r\n            if (!nextVisibleEntities[entityId]) {\r\n                this._container.removeChild(this._visibleEntities[entityId]);\r\n            }\r\n        }\r\n        for (const entityId in nextVisibleEntities) {\r\n            if (!this._visibleEntities[entityId]) {\r\n                this._container.addChild(nextVisibleEntities[entityId]);\r\n            }\r\n        }\r\n    }\r\n    _render({ mapInAction } = {}) {\r\n        const map = this.root;\r\n        if (!map || mapInAction)\r\n            return;\r\n        const visibleFeatures = this._props.features.filter((feature) => this._isVisible(feature, map.bounds, map.projection));\r\n        let nextViewportObjects;\r\n        if (this._props.maxZoom && map.zoom > this._props.maxZoom) {\r\n            nextViewportObjects = visibleFeatures.map((feature) => ({\r\n                world: map.projection.toWorldCoordinates(feature.geometry.coordinates),\r\n                lnglat: feature.geometry.coordinates,\r\n                clusterId: feature.id,\r\n                features: [feature]\r\n            }));\r\n        }\r\n        else {\r\n            nextViewportObjects = this._props.method.render({\r\n                map,\r\n                features: visibleFeatures\r\n            });\r\n        }\r\n        if (this._props.onRender && this._props.onRender(nextViewportObjects) === false) {\r\n            return;\r\n        }\r\n        const nextVisibleEntities = this._getVisibleEntities(nextViewportObjects);\r\n        this._syncVisibleEntities(nextVisibleEntities);\r\n        this._visibleEntities = nextVisibleEntities;\r\n    }\r\n    _onAttach() {\r\n        this._entitiesCache = {};\r\n        this._visibleEntities = {};\r\n        this._container = new ymaps3.YMapCollection({});\r\n        this.addChild(this._container);\r\n        const onUpdateRender = this._props.tickTimeout ? throttle(this._render, this._props.tickTimeout) : this._render;\r\n        this._mapListener = new ymaps3.YMapListener({ onUpdate: onUpdateRender, onResize: onUpdateRender });\r\n        this.addChild(this._mapListener);\r\n        this._render();\r\n    }\r\n    _onDetach() {\r\n        this.removeChild(this._container);\r\n        this.removeChild(this._mapListener);\r\n        this._entitiesCache = {};\r\n        this._visibleEntities = {};\r\n    }\r\n    _onUpdate() {\r\n        this._render();\r\n    }\r\n}\r\n_a = ymaps3.overrideKeyReactify, _b = ymaps3.overrideKeyVuefy, _c = ymaps3.optionsKeyVuefy;\r\nYMapClusterer.__implName = 'YMapClusterer';\r\nYMapClusterer.defaultProps = defaultProps;\r\n/** @internal */\r\nYMapClusterer[_a] = YMapClustererReactifyOverride;\r\nYMapClusterer[_b] = YMapClustererVuefyOverride;\r\nYMapClusterer[_c] = YMapClustererVuefyOptions;\r\nexport { YMapClusterer };\r\n", "// World at 0 zoom is always 256x256 pixels.\r\nconst worldPixelSize = 256;\r\n/**\r\n * Divides a vector by another one component wise and stores the result into a\r\n * third one.\r\n *\r\n * @param a The dividend vector.\r\n * @param b The divisor vector.\r\n * @param dst The vector the result will be stored to.\r\n * @returns `dst`.\r\n */\r\nfunction divv(a, b, dst = { x: 0, y: 0 }) {\r\n    dst.x = a.x / b.x;\r\n    dst.y = a.y / b.y;\r\n    return dst;\r\n}\r\n/**\r\n * Divides a vector by a scalar and stores the result into a third vector.\r\n *\r\n * @param v The dividend vector.\r\n * @param n The scalar.\r\n * @param dst The vector the result will be stored to.\r\n * @returns `dst`.\r\n */\r\nexport function divn(v, n, dst = { x: 0, y: 0 }) {\r\n    dst.x = v.x / n;\r\n    dst.y = v.y / n;\r\n    return dst;\r\n}\r\nexport function convertPixelSizeToWorldSize(pixel, zoom, dst) {\r\n    const scale = (2 ** zoom / 2) * worldPixelSize;\r\n    return divv(pixel, { x: scale, y: -scale }, dst);\r\n}\r\n", "import { convertPixelSizeToWorldSize, divn } from \"../helpers/utils\";\r\nclass ClusterByGridMethod {\r\n    constructor(gridSize) {\r\n        this._nextFeatureIndex = 0;\r\n        this._featureIdCharCache = {};\r\n        this._gridSize = gridSize;\r\n    }\r\n    _getClusterSizeWorld(targetZoom) {\r\n        return convertPixelSizeToWorldSize({ x: this._gridSize, y: 0 }, targetZoom).x;\r\n    }\r\n    _computeVisibleClusters(size, targetZoom, center) {\r\n        const halfViewportSize = divn(convertPixelSizeToWorldSize(size, targetZoom), 2);\r\n        const top = center.y + halfViewportSize.y;\r\n        const bottom = center.y - halfViewportSize.y;\r\n        const left = center.x - halfViewportSize.x;\r\n        const right = center.x + halfViewportSize.x;\r\n        const clusterSize = this._getClusterSizeWorld(targetZoom);\r\n        const minBucketX = Math.floor(left / clusterSize);\r\n        const maxBucketX = Math.ceil(right / clusterSize);\r\n        const minBucketY = Math.floor(top / clusterSize);\r\n        const maxBucketY = Math.ceil(bottom / clusterSize);\r\n        const result = new Map();\r\n        for (let x = minBucketX; x <= maxBucketX; x++) {\r\n            for (let y = minBucketY; y <= maxBucketY; y++) {\r\n                result.set(`${x}-${y}`, true);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    _clusterize(map, features, targetZoom) {\r\n        const clusters = new Map();\r\n        const clusterSize = this._getClusterSizeWorld(targetZoom);\r\n        for (const feature of features) {\r\n            const object = {\r\n                world: map.projection.toWorldCoordinates(feature.geometry.coordinates),\r\n                lnglat: feature.geometry.coordinates,\r\n                clusterId: '',\r\n                features: [feature]\r\n            };\r\n            const clusterX = Math.floor(object.world.x / clusterSize);\r\n            const clusterY = Math.floor(object.world.y / clusterSize);\r\n            const id = `${clusterX}-${clusterY}`;\r\n            let cluster = clusters.get(id);\r\n            if (!cluster) {\r\n                cluster = { sumX: 0, sumY: 0, objects: [], features: [] };\r\n                clusters.set(id, cluster);\r\n            }\r\n            cluster.sumX += object.world.x;\r\n            cluster.sumY += object.world.y;\r\n            cluster.objects.push(object);\r\n            cluster.features.push(object.features[0]);\r\n        }\r\n        return clusters;\r\n    }\r\n    _generateClusterId(features) {\r\n        const result = ['cluster-'];\r\n        features.forEach(({ id }) => {\r\n            if (!this._featureIdCharCache[id]) {\r\n                this._featureIdCharCache[id] = String.fromCharCode(this._nextFeatureIndex);\r\n                this._nextFeatureIndex += 1;\r\n            }\r\n            result.push(this._featureIdCharCache[id]);\r\n        });\r\n        return result.join('');\r\n    }\r\n    render({ map, features }) {\r\n        const targetZoom = Math.round(map.zoom);\r\n        const visibleClusters = this._computeVisibleClusters(map.size, targetZoom, map.projection.toWorldCoordinates(map.center));\r\n        const currentCollection = this._clusterize(map, features, targetZoom);\r\n        const nextViewportObjects = [];\r\n        for (const [clusterId, cluster] of currentCollection.entries()) {\r\n            if (!visibleClusters.get(clusterId))\r\n                continue;\r\n            const length = cluster.objects.length;\r\n            if (length === 1) {\r\n                nextViewportObjects.push({\r\n                    ...cluster.objects[0],\r\n                    clusterId: cluster.features[0].id\r\n                });\r\n            }\r\n            else {\r\n                const world = { x: cluster.sumX / length, y: cluster.sumY / length };\r\n                nextViewportObjects.push({\r\n                    world,\r\n                    lnglat: map.projection.fromWorldCoordinates(world),\r\n                    clusterId: this._generateClusterId(cluster.features),\r\n                    features: cluster.features\r\n                });\r\n            }\r\n        }\r\n        return nextViewportObjects;\r\n    }\r\n}\r\nexport function clusterByGrid({ gridSize }) {\r\n    return new ClusterByGridMethod(gridSize);\r\n}\r\n"],
  "mappings": "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",
  "names": ["YMapClusterer", "clusters", "props", "_a", "_b"]
}
