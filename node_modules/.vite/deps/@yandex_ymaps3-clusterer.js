import "./chunk-EQCVQC35.js";

// node_modules/@yandex/ymaps3-clusterer/dist/esm/YMapClusterer/constants.js
var THROTTLE_DEFAULT_TIMEOUT_MS = 200;

// node_modules/@yandex/ymaps3-clusterer/dist/esm/YMapClusterer/helpers/throttle.js
var throttle = (fn, wait) => {
  let inThrottle;
  let lastFn;
  let lastTime;
  return function() {
    const context = this;
    const args = arguments;
    if (!inThrottle) {
      fn.apply(context, args);
      lastTime = Date.now();
      inThrottle = true;
    } else {
      clearTimeout(lastFn);
      lastFn = setTimeout(() => {
        if (Date.now() - lastTime >= wait) {
          fn.apply(context, args);
          lastTime = Date.now();
        }
      }, Math.max(wait - (Date.now() - lastTime), 0));
    }
  };
};

// node_modules/@yandex/ymaps3-clusterer/dist/esm/YMapClusterer/react/YMapClusterer.js
var YMapClustererReactifyOverride = (YMapClustererI, { reactify, React }) => {
  const YMapClustererReactified = reactify.entity(YMapClustererI);
  const YMapClusterer2 = React.forwardRef((props, ref) => {
    const [clusters, setClusters] = React.useState([]);
    const onRender = React.useCallback((clusters2) => {
      const reactClusters = {};
      clusters2.forEach(({ lnglat, features, clusterId }) => {
        reactClusters[clusterId] = React.createElement(React.Fragment, { key: clusterId }, features.length === 1 ? props.marker(features[0]) : props.cluster(lnglat, features));
      });
      setClusters(Object.values(reactClusters));
      return false;
    }, [props]);
    return React.createElement(
      React.Fragment,
      null,
      React.createElement(YMapClustererReactified, { ...props, ref, onRender }),
      clusters
    );
  });
  return YMapClusterer2;
};

// node_modules/@yandex/ymaps3-clusterer/dist/esm/YMapClusterer/vue/YMapClusterer.js
var YMapClustererVuefyOptions = {
  props: {
    method: { type: Object, required: true },
    features: { type: Array, required: true },
    marker: Function,
    cluster: Function,
    tickTimeout: { type: Number, default: THROTTLE_DEFAULT_TIMEOUT_MS },
    onRender: Function,
    maxZoom: { type: Number }
  }
};
var YMapClustererVuefyOverride = (YMapClustererI, props, { vuefy, Vue }) => {
  const YMapClustererV = vuefy.entity(YMapClustererI, props);
  const YMapCollectionV = vuefy.entity(ymaps3.YMapCollection);
  return Vue.defineComponent({
    name: "YMapClustererContainer",
    props,
    slots: Object,
    setup(props2, { slots }) {
      const clustersVNode = Vue.ref(null);
      const onRender = (clusters) => {
        const vueClusters = {};
        clusters.forEach(({ lnglat, features, clusterId }) => {
          var _a2, _b2;
          vueClusters[clusterId] = Vue.h(Vue.Fragment, { key: clusterId }, features.length === 1 ? (_a2 = slots.marker) === null || _a2 === void 0 ? void 0 : _a2.call(slots, { feature: features[0] }) : (_b2 = slots.cluster) === null || _b2 === void 0 ? void 0 : _b2.call(slots, { coordinates: lnglat, features }));
        });
        clustersVNode.value = Object.values(vueClusters);
        return false;
      };
      return () => [
        Vue.h(YMapClustererV, { ...props2, onRender }),
        Vue.h(YMapCollectionV, () => clustersVNode.value)
      ];
    }
  });
};

// node_modules/@yandex/ymaps3-clusterer/dist/esm/YMapClusterer/YMapClusterer.js
var _a;
var _b;
var _c;
var defaultProps = Object.freeze({
  tickTimeout: THROTTLE_DEFAULT_TIMEOUT_MS
});
var YMapClusterer = class extends ymaps3.YMapComplexEntity {
  constructor(props) {
    super(props);
    this._entitiesCache = {};
    this._visibleEntities = {};
    this._render = this._render.bind(this);
  }
  /**
   * Compare feature coordinates with bounds.
   * Visible in x2 bounds.
   *
   * @param feature
   * @param bounds
   * @param projection
   * @returns either feature belongs to viewport or not
   */
  _isVisible(feature, bounds, projection) {
    const { x, y } = projection.toWorldCoordinates(feature.geometry.coordinates);
    const { x: x1, y: y1 } = projection.toWorldCoordinates(bounds[0]);
    const { x: x2, y: y2 } = projection.toWorldCoordinates(bounds[1]);
    const boundsWidth = x2 - x1;
    const boundsHeight = y1 - y2;
    return x1 - boundsWidth / 2 <= x && x2 + boundsWidth / 2 >= x && y1 + boundsHeight / 2 >= y && y2 - boundsHeight / 2 <= y;
  }
  /**
   * Get entity from store or create it
   *
   * @param feature
   * @param entityId
   * @param length count of entities in the cluster
   * @returns ready to add to map entity
   */
  _getEntity({ lnglat, features, clusterId: entityId }) {
    let entity = this._entitiesCache[entityId];
    if (!entity) {
      if (features.length === 1) {
        entity = this._props.marker(features[0]);
      } else {
        entity = this._props.cluster(lnglat, features);
      }
      this._entitiesCache[entityId] = entity;
    }
    return entity;
  }
  /**
   * Generate map of new entities based on returned from method objects
   *
   * @param nextViewportObjects clustered objects
   * @returns map of entities for new render
   */
  _getVisibleEntities(nextViewportObjects) {
    const nextVisibleEntities = {};
    nextViewportObjects.forEach((object) => {
      const entity = this._getEntity(object);
      nextVisibleEntities[object.clusterId] = entity;
    });
    return nextVisibleEntities;
  }
  /**
   * Removes unnecessary entities and adds new to the map
   *
   * @param nextVisibleEntities new entities for matching with existing entities
   */
  _syncVisibleEntities(nextVisibleEntities) {
    for (const entityId in this._visibleEntities) {
      if (!nextVisibleEntities[entityId]) {
        this._container.removeChild(this._visibleEntities[entityId]);
      }
    }
    for (const entityId in nextVisibleEntities) {
      if (!this._visibleEntities[entityId]) {
        this._container.addChild(nextVisibleEntities[entityId]);
      }
    }
  }
  _render({ mapInAction } = {}) {
    const map = this.root;
    if (!map || mapInAction)
      return;
    const visibleFeatures = this._props.features.filter((feature) => this._isVisible(feature, map.bounds, map.projection));
    let nextViewportObjects;
    if (this._props.maxZoom && map.zoom > this._props.maxZoom) {
      nextViewportObjects = visibleFeatures.map((feature) => ({
        world: map.projection.toWorldCoordinates(feature.geometry.coordinates),
        lnglat: feature.geometry.coordinates,
        clusterId: feature.id,
        features: [feature]
      }));
    } else {
      nextViewportObjects = this._props.method.render({
        map,
        features: visibleFeatures
      });
    }
    if (this._props.onRender && this._props.onRender(nextViewportObjects) === false) {
      return;
    }
    const nextVisibleEntities = this._getVisibleEntities(nextViewportObjects);
    this._syncVisibleEntities(nextVisibleEntities);
    this._visibleEntities = nextVisibleEntities;
  }
  _onAttach() {
    this._entitiesCache = {};
    this._visibleEntities = {};
    this._container = new ymaps3.YMapCollection({});
    this.addChild(this._container);
    const onUpdateRender = this._props.tickTimeout ? throttle(this._render, this._props.tickTimeout) : this._render;
    this._mapListener = new ymaps3.YMapListener({ onUpdate: onUpdateRender, onResize: onUpdateRender });
    this.addChild(this._mapListener);
    this._render();
  }
  _onDetach() {
    this.removeChild(this._container);
    this.removeChild(this._mapListener);
    this._entitiesCache = {};
    this._visibleEntities = {};
  }
  _onUpdate() {
    this._render();
  }
};
_a = ymaps3.overrideKeyReactify, _b = ymaps3.overrideKeyVuefy, _c = ymaps3.optionsKeyVuefy;
YMapClusterer.__implName = "YMapClusterer";
YMapClusterer.defaultProps = defaultProps;
YMapClusterer[_a] = YMapClustererReactifyOverride;
YMapClusterer[_b] = YMapClustererVuefyOverride;
YMapClusterer[_c] = YMapClustererVuefyOptions;

// node_modules/@yandex/ymaps3-clusterer/dist/esm/YMapClusterer/helpers/utils.js
var worldPixelSize = 256;
function divv(a, b, dst = { x: 0, y: 0 }) {
  dst.x = a.x / b.x;
  dst.y = a.y / b.y;
  return dst;
}
function divn(v, n, dst = { x: 0, y: 0 }) {
  dst.x = v.x / n;
  dst.y = v.y / n;
  return dst;
}
function convertPixelSizeToWorldSize(pixel, zoom, dst) {
  const scale = 2 ** zoom / 2 * worldPixelSize;
  return divv(pixel, { x: scale, y: -scale }, dst);
}

// node_modules/@yandex/ymaps3-clusterer/dist/esm/YMapClusterer/methods/clusterByGrid.js
var ClusterByGridMethod = class {
  constructor(gridSize) {
    this._nextFeatureIndex = 0;
    this._featureIdCharCache = {};
    this._gridSize = gridSize;
  }
  _getClusterSizeWorld(targetZoom) {
    return convertPixelSizeToWorldSize({ x: this._gridSize, y: 0 }, targetZoom).x;
  }
  _computeVisibleClusters(size, targetZoom, center) {
    const halfViewportSize = divn(convertPixelSizeToWorldSize(size, targetZoom), 2);
    const top = center.y + halfViewportSize.y;
    const bottom = center.y - halfViewportSize.y;
    const left = center.x - halfViewportSize.x;
    const right = center.x + halfViewportSize.x;
    const clusterSize = this._getClusterSizeWorld(targetZoom);
    const minBucketX = Math.floor(left / clusterSize);
    const maxBucketX = Math.ceil(right / clusterSize);
    const minBucketY = Math.floor(top / clusterSize);
    const maxBucketY = Math.ceil(bottom / clusterSize);
    const result = /* @__PURE__ */ new Map();
    for (let x = minBucketX; x <= maxBucketX; x++) {
      for (let y = minBucketY; y <= maxBucketY; y++) {
        result.set(`${x}-${y}`, true);
      }
    }
    return result;
  }
  _clusterize(map, features, targetZoom) {
    const clusters = /* @__PURE__ */ new Map();
    const clusterSize = this._getClusterSizeWorld(targetZoom);
    for (const feature of features) {
      const object = {
        world: map.projection.toWorldCoordinates(feature.geometry.coordinates),
        lnglat: feature.geometry.coordinates,
        clusterId: "",
        features: [feature]
      };
      const clusterX = Math.floor(object.world.x / clusterSize);
      const clusterY = Math.floor(object.world.y / clusterSize);
      const id = `${clusterX}-${clusterY}`;
      let cluster = clusters.get(id);
      if (!cluster) {
        cluster = { sumX: 0, sumY: 0, objects: [], features: [] };
        clusters.set(id, cluster);
      }
      cluster.sumX += object.world.x;
      cluster.sumY += object.world.y;
      cluster.objects.push(object);
      cluster.features.push(object.features[0]);
    }
    return clusters;
  }
  _generateClusterId(features) {
    const result = ["cluster-"];
    features.forEach(({ id }) => {
      if (!this._featureIdCharCache[id]) {
        this._featureIdCharCache[id] = String.fromCharCode(this._nextFeatureIndex);
        this._nextFeatureIndex += 1;
      }
      result.push(this._featureIdCharCache[id]);
    });
    return result.join("");
  }
  render({ map, features }) {
    const targetZoom = Math.round(map.zoom);
    const visibleClusters = this._computeVisibleClusters(map.size, targetZoom, map.projection.toWorldCoordinates(map.center));
    const currentCollection = this._clusterize(map, features, targetZoom);
    const nextViewportObjects = [];
    for (const [clusterId, cluster] of currentCollection.entries()) {
      if (!visibleClusters.get(clusterId))
        continue;
      const length = cluster.objects.length;
      if (length === 1) {
        nextViewportObjects.push({
          ...cluster.objects[0],
          clusterId: cluster.features[0].id
        });
      } else {
        const world = { x: cluster.sumX / length, y: cluster.sumY / length };
        nextViewportObjects.push({
          world,
          lnglat: map.projection.fromWorldCoordinates(world),
          clusterId: this._generateClusterId(cluster.features),
          features: cluster.features
        });
      }
    }
    return nextViewportObjects;
  }
};
function clusterByGrid({ gridSize }) {
  return new ClusterByGridMethod(gridSize);
}
export {
  YMapClusterer,
  clusterByGrid
};
//# sourceMappingURL=@yandex_ymaps3-clusterer.js.map
