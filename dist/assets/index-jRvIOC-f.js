const M=(c,t)=>{let e,s,r;return function(){const o=this,i=arguments;e?(clearTimeout(s),s=setTimeout(()=>{Date.now()-r>=t&&(c.apply(o,i),r=Date.now())},Math.max(t-(Date.now()-r),0))):(c.apply(o,i),r=Date.now(),e=!0)}},E=(c,{reactify:t,React:e})=>{const s=t.entity(c);return e.forwardRef((o,i)=>{const[n,l]=e.useState([]),u=e.useCallback(h=>{const a={};return h.forEach(({lnglat:f,features:d,clusterId:_})=>{a[_]=e.createElement(e.Fragment,{key:_},d.length===1?o.marker(d[0]):o.cluster(f,d))}),l(Object.values(a)),!1},[o]);return e.createElement(e.Fragment,null,e.createElement(s,{...o,ref:i,onRender:u}),n)})},v={props:{method:{type:Object,required:!0},features:{type:Array,required:!0},marker:Function,cluster:Function,tickTimeout:{type:Number,default:200},onRender:Function,maxZoom:{type:Number}}},T=(c,t,{vuefy:e,Vue:s})=>{const r=e.entity(c,t),o=e.entity(ymaps3.YMapCollection);return s.defineComponent({name:"YMapClustererContainer",props:t,slots:Object,setup(i,{slots:n}){const l=s.ref(null),u=h=>{const a={};return h.forEach(({lnglat:f,features:d,clusterId:_})=>{var p,m;a[_]=s.h(s.Fragment,{key:_},d.length===1?(p=n.marker)===null||p===void 0?void 0:p.call(n,{feature:d[0]}):(m=n.cluster)===null||m===void 0?void 0:m.call(n,{coordinates:f,features:d}))}),l.value=Object.values(a),!1};return()=>[s.h(r,{...i,onRender:u}),s.h(o,()=>l.value)]}})};var x,b,g;const Y=Object.freeze({tickTimeout:200});class y extends ymaps3.YMapComplexEntity{constructor(t){super(t),this._entitiesCache={},this._visibleEntities={},this._render=this._render.bind(this)}_isVisible(t,e,s){const{x:r,y:o}=s.toWorldCoordinates(t.geometry.coordinates),{x:i,y:n}=s.toWorldCoordinates(e[0]),{x:l,y:u}=s.toWorldCoordinates(e[1]),h=l-i,a=n-u;return i-h/2<=r&&l+h/2>=r&&n+a/2>=o&&u-a/2<=o}_getEntity({lnglat:t,features:e,clusterId:s}){let r=this._entitiesCache[s];return r||(e.length===1?r=this._props.marker(e[0]):r=this._props.cluster(t,e),this._entitiesCache[s]=r),r}_getVisibleEntities(t){const e={};return t.forEach(s=>{const r=this._getEntity(s);e[s.clusterId]=r}),e}_syncVisibleEntities(t){for(const e in this._visibleEntities)t[e]||this._container.removeChild(this._visibleEntities[e]);for(const e in t)this._visibleEntities[e]||this._container.addChild(t[e])}_render({mapInAction:t}={}){const e=this.root;if(!e||t)return;const s=this._props.features.filter(i=>this._isVisible(i,e.bounds,e.projection));let r;if(this._props.maxZoom&&e.zoom>this._props.maxZoom?r=s.map(i=>({world:e.projection.toWorldCoordinates(i.geometry.coordinates),lnglat:i.geometry.coordinates,clusterId:i.id,features:[i]})):r=this._props.method.render({map:e,features:s}),this._props.onRender&&this._props.onRender(r)===!1)return;const o=this._getVisibleEntities(r);this._syncVisibleEntities(o),this._visibleEntities=o}_onAttach(){this._entitiesCache={},this._visibleEntities={},this._container=new ymaps3.YMapCollection({}),this.addChild(this._container);const t=this._props.tickTimeout?M(this._render,this._props.tickTimeout):this._render;this._mapListener=new ymaps3.YMapListener({onUpdate:t,onResize:t}),this.addChild(this._mapListener),this._render()}_onDetach(){this.removeChild(this._container),this.removeChild(this._mapListener),this._entitiesCache={},this._visibleEntities={}}_onUpdate(){this._render()}}x=ymaps3.overrideKeyReactify,b=ymaps3.overrideKeyVuefy,g=ymaps3.optionsKeyVuefy;y.__implName="YMapClusterer";y.defaultProps=Y;y[x]=E;y[b]=T;y[g]=v;const w=256;function z(c,t,e={x:0,y:0}){return e.x=c.x/t.x,e.y=c.y/t.y,e}function I(c,t,e={x:0,y:0}){return e.x=c.x/t,e.y=c.y/t,e}function C(c,t,e){const s=2**t/2*w;return z(c,{x:s,y:-s},e)}class O{constructor(t){this._nextFeatureIndex=0,this._featureIdCharCache={},this._gridSize=t}_getClusterSizeWorld(t){return C({x:this._gridSize,y:0},t).x}_computeVisibleClusters(t,e,s){const r=I(C(t,e),2),o=s.y+r.y,i=s.y-r.y,n=s.x-r.x,l=s.x+r.x,u=this._getClusterSizeWorld(e),h=Math.floor(n/u),a=Math.ceil(l/u),f=Math.floor(o/u),d=Math.ceil(i/u),_=new Map;for(let p=h;p<=a;p++)for(let m=f;m<=d;m++)_.set(`${p}-${m}`,!0);return _}_clusterize(t,e,s){const r=new Map,o=this._getClusterSizeWorld(s);for(const i of e){const n={world:t.projection.toWorldCoordinates(i.geometry.coordinates),lnglat:i.geometry.coordinates,clusterId:"",features:[i]},l=Math.floor(n.world.x/o),u=Math.floor(n.world.y/o),h=`${l}-${u}`;let a=r.get(h);a||(a={sumX:0,sumY:0,objects:[],features:[]},r.set(h,a)),a.sumX+=n.world.x,a.sumY+=n.world.y,a.objects.push(n),a.features.push(n.features[0])}return r}_generateClusterId(t){const e=["cluster-"];return t.forEach(({id:s})=>{this._featureIdCharCache[s]||(this._featureIdCharCache[s]=String.fromCharCode(this._nextFeatureIndex),this._nextFeatureIndex+=1),e.push(this._featureIdCharCache[s])}),e.join("")}render({map:t,features:e}){const s=Math.round(t.zoom),r=this._computeVisibleClusters(t.size,s,t.projection.toWorldCoordinates(t.center)),o=this._clusterize(t,e,s),i=[];for(const[n,l]of o.entries()){if(!r.get(n))continue;const u=l.objects.length;if(u===1)i.push({...l.objects[0],clusterId:l.features[0].id});else{const h={x:l.sumX/u,y:l.sumY/u};i.push({world:h,lnglat:t.projection.fromWorldCoordinates(h),clusterId:this._generateClusterId(l.features),features:l.features})}}return i}}function S({gridSize:c}){return new O(c)}export{y as YMapClusterer,S as clusterByGrid};
